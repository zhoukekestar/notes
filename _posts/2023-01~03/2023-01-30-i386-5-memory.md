---
layout: post
title:  "80386 - 内存管理"
date:  2023-01-30
tags: [note, system]
---

  做了这么多铺垫，终于可以完整了解一下整体的 80386 的内存管理。


# 验证 GDT 步骤

## 终端 1

```sh
# 启动 ubuntu 16 虚拟机
# 参考 https://zhoukekestar.github.io/notes/2023/01/18/vm.html
$ qemu-system-i386 \
  -drive "file=./ubuntu16.img.qcow2,format=qcow2" \
  -m 2G \
  -nic user,hostfwd=tcp::10022-:22 \
  -monitor stdio

# 查看虚拟机 GDT
$ (qemu) info registers
...
GDT=     f67c4000 000000ff
...

```

## 终端 2

```sh
# 新开终端，连接虚拟机
$ ssh zkk@localhost -p10022

# 新建 dt.asm, 内容如下
$ cat dt.asm
section	.text
	global _start
_start:
	SGDT	[gdtcopy]
	SLDT	[ldtcopy]

section	.data
gdtcopy times 16 db 'x'
ldtcopy times 16 db 'x'

# 编译
$ nasm -f elf dt.asm
$ ld dt.o

# 调试
# 参考 https://zhoukekestar.github.io/notes/2023/01/30/debug.html
$ gdb ./a.out
# 开启汇编视图
(gdb) layout asm
# 断点
(gdb) starti
# step into
(gdb) si
│   0x8049000 <_start>      sgdtl  0x804a000
│  >0x8049007 <_start+7>    sldt   0x804a010
# 查看 GDT 内容
# 结果和虚拟机显示的 GDT=     f67c4000 000000ff 中相对应
(gdb) x/12x 0x804a000
0x804a000:      0x400000ff      0x7878f67c      0x78787878      0x78787878
```

# 验证 Segment Register


```sh
# 显示 CPU 寄存器
(qemu) info registers
...
GS =00e0 f67ce8c0 00000018 00409100 DPL=0 DS   [--A]
...
GDT=     f67c4000 000000ff
...

# 通过段转化，计算 DS 段寄存器的物理地址
# [BASE] + [INDEX] * 8 = 0xf67c4000 + (0xe0 >> 3) * 8 = 0xf67c40e0

# 查看相关的物理内存内容，可以看到相关的段描述已经被预加载至 Hidden Descriptor
# 参考 https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm
# 参考 https://techiefood4u.files.wordpress.com/2019/08/cao_unit_ii.pdf 查看 Hidden Part of Segment Selector
#   * Base Address + Limit + Access Information
#   * 0xe8c00018 0xf640917c 转成上述格式就是 f67ce8c0(Base) 00000018(limit) 00409100(Access)
(qemu) x/2x 0xf67c40e0
f67c40e0: 0xe8c00018 0xf640917c

```

# 验证 Paging

  <!-- TODO -->
  获取 cr3 需要内核态权限才能获取

* /proc/pid/maps , https://www.baeldung.com/linux/proc-id-maps
* /proc/pid/pagemap
  * 此文件是一个虚拟文件，https://unix.stackexchange.com/questions/457196/why-is-cat-proc-pid-pagemap-not-giving-any-output
  * https://github.com/dwks/pagemap

<!--
* `Segment Descriptor`
  * GDT = [BASE] + [INDEX] * 8 = 0xf67c4000 + (0x7b >> 3) * 8 = 0xf67c4078
  * LDT = [BASE] + [INDEX] * 8 = 0x00 + (0x7b >> 3) * 8 = 0x78
* `OFFSET` = 0x804a000
* `LINER ADDRESS` = 0x78 + 0x804a000 = 0x804a078
* CR3 = 0x30c65d00
* DIR_ADR = ((0x30c65d00 >> 12) + (0x804a078 >> 22)).toString(16) -->

