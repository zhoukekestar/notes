---
layout: post
title:  "80386 模拟器源码分析 (4)"
date:  2023-01-17
tags: [note, system]
---

  段描述符、段描述符表

# 段描述符 Segment Descriptor

来自 [MIT](https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm)

![](https://pdos.csail.mit.edu/6.828/2005/readings/i386/fig5-3.gif)

来自 [UNM](http://ece-research.unm.edu/jimp/310/slides/micro_arch2.html)

![](https://ece-research.unm.edu/jimp/310/slides/micro_arch2-2.gif)

<!-- 来自 [wiki](https://en.wikipedia.org/wiki/Segment_descriptor)

![image](https://user-images.githubusercontent.com/7157346/212797570-a959ca08-30d8-4ef8-af38-606dc6be499d.png) -->


段描述符共 64 位

* [0..15] 16 位，为 Segment Limit
  * 和 [48..51] 的 4 位加在一起，共 20 位 Limit
* [16..39] 24 位，为 Segment Base
  * 和 [56..63] 的 8 位加在一起，共 32 位 Base
* [40..47] 8 位，为 Access Rights 访问权限
  * `A` 1 位，Accessed 缩写
    * 表示是否被访问过，A=0 表示没有，A=1 表示被访问过
  * `TYPE` 3 位，类型
    * `000` Data, read-only
    * `001` Data, read/write
    * `010` Stack, read-only
    * `011` Stack, read/write
    * `100` Code, execute-only，非一致代码段
    * `101` Code, execute/read，非一致代码段
    * `110` Code, execute-only, conforming, 一致代码段
    * `111` Code, execute/read, conforming，一致代码段
      * 第二位的 01 表示是否为一致代码段，也就是能否被低级权限代码执行的意思。
  * `S` 1 位，System 缩写
    * 表示 S=0 表示系统描述，S=1 表示代码、数据或堆栈描述
  * `DPL` 2 位，Descriptor Privilege Level 缩写
    * 表示权限级别，0 为特权，3 为最低。
  * `P` 1 位，Present 缩写
    * 表示当前描述是否有效，P=0 为无效（操作系统可自行扩展），P=1 为有效（仅对 CPU）
* [48..51] 4 位，为 Limit 扩展字节，与前面加一起共 20 位
* [52..55] 4 位，为 Segment Descriptors 段描述
  * `U` 用户自定义位
  * `X` Intel 保留位
  * `D` 指令位数，D=0 为 16 位，D=1 为 32 位
  * `G` 段大小，G=0 为 1b ~ 1MB，G=1 为 4KB ~ 4GB
* [56..63] 8 位，为 Base 扩展字节，与前面加一起共 32 位


参考：
* [https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm](https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm)
* [http://ece-research.unm.edu/jimp/310/slides/micro_arch2.html](http://ece-research.unm.edu/jimp/310/slides/micro_arch2.html)
* [https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html](https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html)

# 描述符表 Descriptor Tables

  描述符表分为 Global Descriptor Table（全局描述符表） 与 Local Descriptor Table （局部描述符表）。

  描述符表，本质上就是一个 8 字节（64位）的数组。

  GDT 和 LDT 在内存中的地址，分别通过 GDTR（Global Descriptor Table Register） 与 LDTR（Local Descriptor Table Register）来指定。

  * GDT 的第一个为空，用于表示 null selector，从而避免自动转义。

  在汇编中，通过 [LGDT (Load Global Descriptor Table)](https://pdos.csail.mit.edu/6.828/2005/readings/i386/LGDT.htm) 和 [SGDT (Store Global Descriptor Table)](https://pdos.csail.mit.edu/6.828/2005/readings/i386/SGDT.htm) 指令来读写 GDTR。对于 LDTR，同理有 LLDT 与 SLDT 指令。


参考：
* [https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm](https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_01.htm)

# 测试 GDT

编写汇编

```gdttest.asm
section	.text
	global _start
_start:
	SGDT	[gdtcopy]
section	.data
gdtcopy times 8 db '*'
```

```sh
# 启动虚拟机
# M1 mac 上，virtualbox 还是测试版，无法使用，用 qemu 来模拟
# 并开启网络方便 ssh，不然 qemu 自带的无法复制，粘贴，很难受
$ qemu-system-x86_64 \
  -drive "file=./ubuntu.img.qcow2,format=qcow2"\
  -m 2G \
  -smp 2 \
  -net user,hostfwd=tcp::10022-:22 \
  -net nic

# 连接到 qemu 虚拟机
$ ssh user@localhost -p10002

# 编辑 asm 文件
$ vi gdttest.asm

# vi 删除所有
(vi):%d
# 粘贴代码
# 保存
(vi):wq

# 编译
$ nasm -f elf gdttest.asm
# 连接
$ ld -m elf_i386 -s -o gdttest gdttest.o

# 调试
$ lldb gdttest

# 设置入口断点，因为无法 b main 来断点
(lldb) process launch --stop-at-entry
->  0x8049000 <+0>: sgdtl  0x804a000

# 复制 lldb 提示编译后的那个地址
(lldb) x 0x804a000
0x0804a000: 2a 2a 2a 2a 2a 2a 2a 2a 00 2e 73 68 73 74 72 74  ********..shstrt

# 下一步
(lldb) n

# 再次查看，可以看到 7f 00 00 10 00 00 （12 * 4 = 48位）的内容
(lldb) x 0x804a000
0x0804a000: 7f 00 00 10 00 00 2a 2a 00 2e 73 68 73 74 72 74  ......**..shstrt
(lldb)
```

